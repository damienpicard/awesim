# -*- coding: utf-8 -*-

"""
This module contains tools to:
    1) access simulation parameters and results generated by dymola in 
       .mat files, or having exactly the same structure
    2) keep track of a (unlimited) amount of these simulation output files

Three classes are defined:
    1) Simulation
    2) Simdex
    3) Process

The main properties of those classes are discussed below.
One function is also defined: load_simdex(filename).  This function loads the
desired simdex that was previously saved with Simdex.save(filename)

class Simulation:
-----------------
    Class for doing operations one 1 single simulation file
    The simualation files are supposed to be generated by Dymola, or at 
    least have the same structure.  
    A Simulation object contains all the (useful) info that is in the .mat file.
    Therefore, objects of the Simulation class are relatively memory intensive,
    depending on the size of the .mat file.
    
    Most important attributes are:
        - self.filename (path to the .mat file)
        - self.names (list of all variable and parameter names)
        - self.dataInfo (mapping of vars and pars to data1 and data2)
        - self.data1 (contains the values of the parameters)
        - self.data2 (contains the values of the variables (timeseries))
    
    Most important methods are:
        - get_value(name) : retreives the value(s) for name, name can be 
          a parameter or a variable
        - exist(regex) : returns all vars and pars that satisfy the regex
        
class Simdex:
-------------
    A Simdex object is an index of all the parameters and variables in several 
    .mat files.  It can be used to select a set of .mat files from a large set
    in order to analyse the results of this set of simulations.
    
    Most important attributes are:
        - self.simulations (a list of filenames of the indexed simulations)
        - self.parameters (a list of all parameters in the set of simulations)
        - self.parametermap (numpy array mapping which simulation has 
          which parameters)        
        - self.parametervalues (numpy array containing the values of the 
          mapped parameters)
        - self.variables (a list of all variables in the set of simulations)
        - self.variablemap (numpy array mapping which simulation has 
          which variables)
        - self.filterset (dictionary tracking all executed filter options on 
          the current set) 
          
        There is no attribute containing the variable values themselves because 
        that would blow up the size of simdex.  These values are kept in the 
        original .mat files and only extracted when needed

Most important methods (* = implemented):

    * __init__(folder): create simdex based from all .mat simulation files in 
      the current folder
    - update(folderlist): update simdex with all .mat files found in a list of 
      folders. Checks if the found files are already in simulations, else they 
      are added and their parameters and ALL attributes are updated with the 
      info found in the new files
    * remove(sim_id): remove a simulation from the simdex
    * print(): gives a nice overview of the indexed simulations 
    * filter(dictionary): this method takes as input a dictionary with parameter
      name/value pairs.   It returns a new Simdex object with those simulations
      that have exactly the same values for those parameters.  
      If a parameter is asked with '*' as value, all simulations that HAVE 
      the parameter are selected.
    * getidentical(sim_id):  this method takes as input a simulation number and 
      returns a new simdex object all simulations with identical parameter set 
      (so all variants of the model with only changed parameter values).  
    * exist(re): similar to Simulation.exist method. Give a search string as re 
      (regular expression) and you get a list of all parameters and variables 
      that satisfy the re. 
    * plot(var): directly create a plot showing the given var for each of the 
      simulations in self.
    - get_values(var or par): get an array with the values of the variable or
      parameter for each of the simulations in the simdex
    * get_parameter(par): to be merged in get_values!!
    * save(filename): saves the simdex by pickling (cPickle) to filename.  The 
      simdex can be loaded later on with the function load_simdex(filename). 
      This is no method of the class Simdex, so to be imported separately from
      this module
      
This info AND more details can be found in the docstrings of each of these
classes, functions and methods

Changes
(see also https://github.com/saroele/Simulation-Management)

20110823 - Sorting of parameters and variables for speed improvements

"""

import numpy as np
import os
import scipy.io
import re
import copy
import matplotlib.pyplot as plt
from matplotlib.dates import date2num
import cPickle as pickle
import bisect
import tables as tbl
from datetime import datetime, timedelta
import pandas


#from enthought.traits.api import *
#from enthought.traits.ui.api import *

__author__ = "Roel De Coninck"
__version__ = "0.0.1"



class Simulation:
    """
    Class for doing operations one 1 single simulation file
    The simualation files are supposed to be generated by Dymola, or at 
    least have the same structure.  
    A Simulation object contains all the (useful) info that is in the .mat file.  
    Therefore, objects of the Simulation class are relatively memory intensive,
    depending on the size of the .mat file.
    
    Most important attributes are:
        - self.filename (path to the .mat file)
        - self.names (list of all variable and parameter names)
        - self.dataInfo (mapping of vars and pars to data1 and data2)
        - self.data1 (contains the values of the parameters)
        - self.data2 (contains the values of the variables (timeseries))
    
    Most important methods are:
        - get_value(name) : retreives the value(s) for name, name can be 
          a parameter or a variable
        - exist(regex) : returns all vars and pars that satisfy the regex
    
    """
    
    def __init__(self, filename, verbose = False):
        ''' 
        Create a Simulation object from a .mat file
        The filename can be an absolute path, or a filename in the current work
        directory, but it must NOT have a .mat extension.
        '''
        
        self.verbose = verbose        
        # turn filename in an absolute path
        # no .mat extension needed, it is added by the scipy.io.loadmat method
        filename = os.path.abspath(filename)
        try:
            d = scipy.io.loadmat(filename, chars_as_strings = False)
            # if all goes well, d is a dictionary 
            
        except(UnicodeDecodeError):
            print 'This error is caused by non-ascii characters in the .mat file\
             like Â°C'
            print 'Modify the scipy.io.mio4.py file by adding ,"replace" in the\
             line that causes the error'
            raise
        
        # check the fields of d to make sure we're having a dymola file        
        try:
            for field in ['dataInfo', 'name', 'data_1', 'data_2'] :
                # here we create numpy arrays with names dataInfo, name, 
                # data_1 and data_2
                stringske = field + '=d[field].transpose()'
                exec(stringske)
        except :
            print '%s is no Dymola file.  No Simulation object created' % \
                (filename)
            raise IOError
                
        # Now we have dataInfo, data_1 and data_2 from the first Dymola file

        # data_1 contains the values of the parameters
        # data_2 contains the values of the variables (timeseries)
        # name contains parameter and variable names but it is 
        # still 'transposed'.  
        # dataInfo contains all metadata about parameters and variables 

        # For future reference, it's important to understand how the data 
        # is structured.  dataInfo has 4 columns and contains a row for
        # each row of names
        
        # Matrix with 4 columns defining the data of the signals:
        # dataInfo(i, 1)= j: name i data is stored in matrix "data_j".
        # dataInfo[0, 0] = 0, means that names[0] is used as abscissa
        # for ALL data matrices!  Normally, names[0]='Time'
        #
        # dataInfo(i, 2)= k: name i data is stored in column abs(k) of matrix
        # data_j with sign(k) used as sign.
        #
        # dataInfo(i, 3)= 0: Linear interpolation of the column data
        # = 1..4: Piecewise convex hermite spline interpolation
        # of the column data. Curve is differentiable upto
        # order 1..4. The spline is defined by a polygon.
        # It touches the polygon in the middle of every segment
        # and at the beginning and final point. Between such
        # points the spline is convex. The polygon is also the
        # convex envelope of the spline.
        #
        # dataInfo(i, 4)= -1: name i is not defined outside of the defined 
        # time range
        # = 0: Keep first/last value outside of time range
        # = 1: Linear interpolation through first/last two points outside
        # of time range.
        

        names = [] 
        # names will be list with names of all parameters and variables 
               
        for i in range(name.shape[0]):
            names.append(''.join(name[i, :]).strip())        
        
                
        self.names = names
        self.dataInfo = dataInfo
        self.data_1 = data_1
        self.data_2 = data_2
        self.filename = filename

    def __str__(self):
        print self.filename
        
        return self.filename
        
    def __len__(self):
        return len(self.simulations)


    def get_value(self, name):
        '''
        get_value(self, name)
    
        This function returns a numpy array with the value(s) of 'name' 
        '''
        
        result = []
        try:
            name_index = self.names.index(name)
        except (ValueError):
            print '%s not found in %s' % (name, self.filename)
            print 'Did you mean one of the following: '
            print self.exist(name)
            raise
            
        possign = self.dataInfo[name_index, 1]
        pos = abs(possign)
        #pos is the row number in data_1 or data_2
        sign = np.sign(possign)
        #sign indicates the sign of the values 
        if self.dataInfo[name_index, 0] == 1:
            source = 'self.data_1'
            # it is a parameter, found in data_1
            stringske = "result=" + source + "[:,pos-1][0]*sign"
        elif self.dataInfo[name_index, 0] == 2 or \
            self.dataInfo[name_index, 0] == 0:
            source = 'self.data_2'
            # important: by testing I found out that get_value for variables
            # gives the last value 2 times.  So I omit the last value here.
            stringske = "result=" + source + "[:-1, pos-1]*sign"
        else:
            raise ValueError('name not found')
        
        exec(stringske)
        return result
        
    def exist(self, regex): 
        """
        exist(regex) 
        
        regex = regular expression, not case sensitive
                
        This method searches for parameter and variable names matching the 
        regular expression in self.names.
        It returns a list with all matching names from self.names
        
        Attention: if you want to check if eg.  c[3].T exists, you have to 
        escape the [ and ] with a backlslash, like this:
        self.exist('c\[3\].T). Otherwise c3.T is sought for. This is 
        because in regex syntax, [] is used to indicate a set of characters.
                
        """
        
        p = re.compile(regex, re.IGNORECASE)
        matches = []
        for i in range(0, len(self.names)):
            m = p.search(self.names[i])
            if m:
                matches.append(self.names[i])
        
        return matches

    def separate(self):
        '''
        separate()
        
        Separates variables from parameters and adds 2 lists and 1 numpy array 
        as attributes:
            - list parameters (sorted)
            - list variables (sorted)
            - numpy array parametervalues 
        This method returns True if successfull
        '''
        # We create a loop over each of the elements in names, check if it is 
        # parameter or variable. We update the attributes parameters and 
        # variables, and if it is a parameter, we put the value in 
        # parametermap
    
        parameters = []
        variables = []
        parametervalues = []
        # parametervalues is a list with the values of the parametes for this
        # run.  Will be converted to array and become self.parametervalues
        
        for i in range(len(self.names)):
            par_or_var = self.names[i] #string with the name of the par or var
            
            possign = self.dataInfo[i, 1]
            pos = abs(possign)
            #pos is the row number in data_1 or data_2
            sign = np.sign(possign)
            #sign indicates the sign of the values 
    
            if self.dataInfo[i, 0] == 1:
                # par_or_var is a parameter
                parameters.append(par_or_var)
                parametervalues.append(self.data_1[0, pos-1] * sign)
    
            elif self.dataInfo[i, 0] == 2 or self.dataInfo[i, 0] == 0:
                # par_or_var is a variable (if == 0: time)
                variables.append(par_or_var)
            
            else:
                print par_or_var
                raise LookupError('Couldnt find this value in dataInfo')
            
        
        zipped = zip(parameters, parametervalues)
        zipped.sort()
        self.parametervalues = np.array([v for p,v in zipped]) 
        self.parameters = [p for p,v in zipped]
        self.variables = variables
        self.variables.sort()
        
        return True

    def extract(self, var, arrays='sum'):
        """Return dictionary with values of the variables/parameters to extract
        
        This method takes a dictionary as input with short_name/full_name pairs.
        It returns a dictionary with short_name/value pairs, value = numpy array.
        
        Important: value is ALWAYS a np.array, even if is it a single value
        
        Handling of arrays is implemented like this:
            - for the array variables you wish to get, replace the [i] (i=int)
              by [x].
              Example: discFullDyn20.tabs.tabs[x].nakedTabs.C2.[1].C' 
            - All values for all present 'x' will be extracted
            - argument arrays defines what happens with these values:
                - arrays='sum' (default): returns the sum of all values
                - arrays='average' returns the average of all values
                - arrays='each' : returns an array with all the values
            - Attention, the array argument defines the action for ALL arrays.
        
        If a long_name is not found, the method passes on, no exception raised!
        
        First version 20110831, RDC
        
        20111123 - raise no exception if a variable is not found
        20111128 - all values are numpy arrays. The reason for doing this is 
                   to make postprocessing more straightforward and robust
        """
        
        
                
        r = {}
        for short_name in var:        
            long_name = var[short_name]
            # check for array first            
            if long_name.find('[x]') > -1:
                # treat the array                
                var_name = long_name.replace('[x]', '\[[0-9]*\]')
                var_name = var_name + '$'
                # we make a list of all present array variables                    
                array_vars = self.exist(var_name)
                # we put all values in an array, as columns
                try:
                    array = self.get_value(array_vars[0])
                except(ValueError, IndexError):
                    # The array was not found: just pass to the next
                    pass
                else:
                    for v in array_vars[1:]:
                        array = np.column_stack((array, self.get_value(v)))                    
                    if arrays == 'sum':
                        r[short_name] = array.sum(axis=1)
                    elif arrays == 'mean':
                        r[short_name] = array.mean(axis=1)
                    elif arrays == 'each':
                        r[short_name] = array
                    else:
                        raise NotImplementedError('arrays='+arrays+' is an unvalid argument')    
            else: 
                # the variable is NO array
                try:
                    value = self.get_value(var[short_name])
                except ValueError:
                    # the variable is not found.  No problem, pass to the next.                    
                    pass
                else:
                    if not isinstance(value, np.ndarray):
                        r[short_name] = np.array(value, ndmin=1)
                    else:
                        r[short_name] = value
                        
        return r
        
    def get_objects(self, mother=''):
        """Get the names of the objects in a mother model
        
        Returns a list with the model names (part before the '.')
        A mother name can be specified as a string (full name up to the model).
        Example: mother = 'foo.fooBar'
        If no mother model is specified, this method gets all the main objects, 
        except 'Time'.
        
        If needed, speed can be improved by using sorted lists 
        Doesn't work with arrays yet (to do that, excape the [ and ] 
        in the mother name)
        
        First version: 20110906, RDC        
        
        """
        
        try:
            test = self.variables
        except AttributeError:
            self.separate()
        
        objects = []
        if mother == '':
            search_in = copy.copy(self.variables)
            search_in.extend(self.parameters)
            search_in.remove('Time')
            try:
                search_in.remove('stateSelect')
            except ValueError:
                pass
            index = 0
        else:
            # make the list with all variables and parameters in the mother model 
            mother_dot = mother + '.'            
            search_in = self.exist(mother_dot)
            index = mother_dot.count('.')
            
        for v in search_in:    
            potential_model = v.split('.')[index]
            try:
                objects.index(potential_model)
            except ValueError:
                objects.append(potential_model)
        try:
            objects.remove('stateSelect')
        except ValueError:
            pass
                   
        
        return objects


    def postprocess(self, process):
        """
        Return a dictionary with results as defined in process
        
        A difference is made between single line assignments (x = ...) 
        and multiline statements (if ...).  
        Therefore, the pp string can be multiline,
        and multistatements.  The distinction is made based on the second item
        after doing a pp.split(' '):
            - if it is a '=', the pp-string is an assignement and is processed 
              like that
            - else, a different syntax is applied cause the spaces in the 
              multiline expression can be of syntactic importance.  
              I still have to develop this, and the point that I didn't solve 
              yet is the attribution of the result.  If you have a string like
              if a>0:
                  b=1
              else:
                  b=2
              you have to check each line, replace a and b with their full names
              (in case of mothers) and recompose the multiline string with the 
              same spaces. Surrounding each variable name with eg '$' could be
              a good solution.  
                
        the multline thing is not implemented yet.
        
        """
        
        def convert(string):
            """
            Return a dictionary with shortname/value pairs 
            as result of a single postprocessing line string
            """

            returndic = {}
            splitted = string.split(' ')
            # First check if we need to loop over the mothers
            apply_on_mothers = False
            for i in splitted:
                # now we will treat each part of the string individually
                if process.sub_vars.has_key(i) or process.sub_pars.has_key(i):
                    apply_on_mothers = True
                    break
            
            # Now process the string            
            if not apply_on_mothers:
                # evaluate the string, and by passing the result dictionary 
                # as locals, the variables are known                
                returndic[splitted[0]] = eval(' '.join(splitted[2:]), globals(), result)
            else:
                # we need to find all variables and add the mothers to them
                for m in process.mothers:    
                    composed = []
                    newvar = '_'.join([m,splitted[0]]).replace('.','_')
                    for s in splitted[2:]:
                        fullname = '_'.join([m,s]).replace('.','_')
                        #print fullname
                        if result.has_key(fullname):
                            # a variable we need to get
                            composed.append(fullname)
                        else:
                            """ 
                            There are different possibilities. 
                            - it is an operation (like +, -, /, ...) ==> append to composed
                            - it is a command (like np.trapz(var) ==> not yet implmented
                            - it is a variable that does not occur in this simulation:
                                appending it to composed will lead to a name error
                                because it is not present in the result dict.  
                                For now, we just catch the error and print a warning
                            """                            
                            composed.append(s)
                    #print 'composed string: ', newvar, ' = ', ' '.join(composed)
                    try:
                        returndic[newvar] = eval(' '.join(composed), globals(), result)
                    except(NameError) as e:
                        print 'This pp string could not be evaluated:'
                        print newvar, ' = ', ' '.join(composed)
                        print 'Error message =  %s' % e
                    except:
                        print 'Error during this evaluation:'
                        print newvar, ' = ', ' '.join(composed)
                        raise
                 
                # To ensure that the newly created var can be used later on:
                process.sub_vars[splitted[0]] = splitted[0]

            return returndic
            

        def aggregate_by_time(signal, time, period=86400, interval=900, label='left'):
            """
            Function to calculate the aggregated average of a timeseries by 
            period (typical a day) in bins of interval seconds (default = 900s).
            
            label = 'left' or 'right'.  'Left' means that the label i contains data from 
            i till i+1, 'right' means that label i contains data from i-1 till i.    
            
            Returns an array with period/interval values, one for each interval
            of the period. 
            
            A few limitations of the method:
                - the period has to be a multiple of the interval
                - periods larger than 1 day are not supported yet
            
            This function can be used in the post-processing
            """
            
            def make_datetimeindex(array_in_seconds, year):
                """
                Create a pandas DateIndex from a time vector in seconds and the year.
                """
                
                start = pandas.datetime(year, 1, 1)
                datetimes = [start + pandas.datetools.timedelta(t/86400.) for t in array_in_seconds]
                
                return pandas.DatetimeIndex(datetimes)
            
            interval_string = str(interval) + 'S'    
            dr = make_datetimeindex(time, 2012)
            df = pandas.DataFrame(data=signal, index=dr, columns=['signal'])
            df15min = df.resample(interval_string, closed=label, label=label)
            
            # now create bins for the groupby() method
            time_s = df15min.index.asi8/1e9
            time_s -= time_s[0]
            df15min['bins'] = np.mod(time_s, period)
            
            df_aggr = df15min.groupby(['bins']).mean()
            
            return df_aggr.values   


        
        vars_and_pars = {}
        vars_and_pars.update(process.variables)
        vars_and_pars.update(process.parameters)
        result = self.extract(vars_and_pars, arrays='each')
        # pass the function to the dictionary in order to get it in the namespace
        result['aggregate_by_time'] = aggregate_by_time
        if process.mothers not in (None, []):
            result['mothers'] = process.mothers
        
        if process.pp is not None:
            for p in process.pp:
                if self.verbose:
                    print p
                d = convert(p)
                result.update(d)
        
        result.pop('aggregate_by_time')        
        return result
        

class Simdex:
    """
    A Simdex object is an index of all the parameters, variables and 
    post-processing results in several .mat files.  
    It is used to treat different result files with a single or different 
    Process objects and keep the full processed results.
    Methods for easy filtering of the set of simulations are provided.
    
    The variables are stored in an h5 file.  Parameters are only stored locally
    in the attributes of the simdex object. When a filter is applied to a
    simdex, the resulting subset of simulations uses the same h5 file, so 
    there is no unnecessary copying of big files on the hard drive.
        
    Overview of most important attributes :
        - self.simulations: a list with unique ID's (SID) of the simulations
        - self.parameters: a list of all parameters in the set of simulations.
          The parameters are listed here with their FULL names
        - self.parametermap: numpy array mapping which simulation has 
          which parameters     
        - self.parametervalues: numpy array containing the values of the 
          mapped parameters
        - self.variables: a list of all variables in the set of simulations. 
          The variables are listed here with their FULL names.
        - self.variablemap: numpy array mapping which simulation has 
          which variables
        - self.filterset: dictionary tracking all executed filter options on 
          the current set
        - self.vardic (optional): a mapping of shortname:longname pairs for 
          variables
        - self.pardic (optional) a mapping of shortname:longname pairs for 
          parameters
        - self.simulations: list of the SID
        - self.files: dictionary with SID:filename pairs
        - self.identifiers: optional dictionary with short meaningful identifiers
          for the simulations.  Is used as legend in plots by default (unless 
          empty).
          
        
    Most important methods (* = implemented):

    * __init__(folder): create simdex based from all .mat simulation files 
      in the current folder
    - update(folderlist): update simdex with all .mat files found in a list of 
      folders. Checks if the found files are already in simulations, else they 
      are added and their parameters and ALL attributes are updated with the 
      info found in the new files
    * remove(sim_id): remove a simulation from the simdex
    * print(): gives a nice overview of the indexed simulations 
    * filter(dictionary): this method takes as input a dictionary with parameter 
      name/value pairs.   It returns a new Simdex object with those simulations
      that have exactly the same values for those parameters.  
      If a parameter is asked with '*' as value, all simulations that HAVE 
      the parameter are selected.
    * getidentical(sim_id):  this method takes as input a simulation number and 
      returns a new simdex object all simulations with identical parameter set 
      (so all variants of the model with only changed parameter values).  
    * exist(re): similar to Simulation.exist method. Give a search string as re 
      (regular expression) and you get a list of all parameters and variables 
      that satisfy the re. 
    * plot(var): directly create a plot showing the given var for each of the 
      simulations in self.
    - get_values(var or par): get an array with the values of the variable or
      parameter for each of the simulations in the simdex
    * get_parameter(par): to be merged in get_values!!
    - save(filename): saves the simdex by pickling (cPickle) to filename.  The 
      simdex can be loaded later on with the function load_simdex(filename)
      
    FEATURES:
    - all found .mat files are tested.  If they to not have the structure of
      a dymola simulation result, they are not indexed

    Important CONVENTIONS:
        - we make a distinction between parameters (one single value)
          and variables (a timeseries of values)
        - simulation identity (SID) is a string with format SIDxxxx
            
    Possible IMPROVEMENTS:
    - multi folder file search
    - support multiple filter (well, it's possible, but the filtersets will 
      become a bit messed up (last filterset overwrites existing filterset if 
      it has the same keys)

    """
    
    def __init__(self, folder='', h5='simdex.h5', process=None, verbose = False):
        '''
        Create a Simdex object.  
        
        Folder is a single folder to be sought for .mat files
        If folder = '', no work directory is indexed.
        
        h5 is the hdf5 file to which this simdex will be linked.
        '''
        # First, initialise some  attributes
        if verbose == True:
            self.verbose = True
        else:
            self.verbose = False
        
        # List with sim ID's, fixed id's for simulation filenames
        # Format: SID1, SID2, SID3, ...        
        self.simulations = []
        # dictionary with SIDx:path pairs (path are full pathnames)        
        self.files = {}
        self.identifiers = {}
        # used for plotting
        self.year = 2010
        self.time4plots = {}
        
        self.process = process
        
        # The pytables file to which this simdex is linked
        # Will be created in the current work directory, check first if it exists
        self.h5_path = os.path.join(os.getcwd(), h5)
        overwrite = 'y'        
        if os.path.exists(self.h5_path):
            print 'This file already exists: %s' % self.h5_path
            overwrite = raw_input('Overwrite (Y/N)? : \n')
            print '\n'
        
        if overwrite == 'y' or overwrite == 'Y':
            self.h5 = tbl.openFile(self.h5_path, 'w', title='Simdex file')
            self.h5.close()
        else:
            raise NotImplementedError("Remove the file first !")
        # dictionary with the filters previously applied on this simdex
        self.filterset = dict()

        if folder == '' :
            # an empty simdex is created
            self.parameters = []
            self.variables = []
            self.parametermap = np.ndarray((0, 1))
            self.parametervalues = copy.copy(self.parametermap)
            self.variablemap = np.ndarray((0, 1))
            
        
        # here we get a list with all files in 'folder' that end with .mat
        
        elif os.path.exists(folder):
            self.scan(folder, process=process)
        else:
            raise IOError('folder does not exist')
        
        if self.h5.isopen:
            self.h5.close()

    def openh5(self):
        """Open the h5 file in append mode"""
        if not self.h5.isopen:
            self.h5 = tbl.openFile(self.h5_path, 'a')
        
    
    def _last_key(self):
        """Return the last key from the pytables file, or '' if empty file"""
        
        self.openh5()
        
        try:        
            meta = self.h5.getNode(self.h5.root.Metadata)
            return meta.cols.SID[-1]
        except(tbl.NoSuchNodeError):
            return ''
            

    def _gen_key(self):
        '''Generate a new key, based on last key'''
        
        # get last key.  
        last_key = self._last_key()
        
        if last_key == '':
            return 'SID' + str(format(0, '04d'))
        else:            
            last_int = int(last_key.split('SID')[-1])
            return 'SID' + str(format(last_int+1, '04d'))

        
    def __str__(self):
        '''
        Prints the Simdex object as a list of the indexed simulations
        with their simID's
        '''
        
        s= '\nSID     Filename\n'
        for k in self.simulations:
            s = ''.join([s, k, ' ', self.files[k], '\n'])
            
        return s
                    
    def scan(self, folder='', process=None):
        """
        Scan the folder for .mat files that are simulation results, and 
        add them to the simdex
        Folder is a single folder to be sought for .mat files
        If folder = '', the current work directory is indexed
        
        """
        
        if process is None:
            process = self.process
        
        if folder == '' :
            filenames = self.__get_files(os.getcwd(), '.mat')
        elif os.path.exists(folder):
            filenames = self.__get_files(folder, '.mat')
        else:
            raise IOError('folder does not exist')
            
        
        # Convert to full path filenames to avoid confusion
        full_path_filenames = []
        for i in range(len(filenames)):
            full_path_filenames.append(os.path.join(folder,filenames[i]))
        
        # run the following loop only when this is the first time files are
        # being indexed
        if self.simulations == []:
            # index is the pointer to the current file in full_path_filenames
            index = -1
            ########################################################################
            # Now we take the first .mat file and use this as a basis for our index
            first_file_indexed = False
            while first_file_indexed == False:
                index += 1
                simulation_file = False
                try:
                    # We try the .mat files one by one until 
                    # we find a first Dymola file
                    sim = Simulation(full_path_filenames[index])
                    simulation_file = True
                except:
                    print '%s is no Dymola file.  It is not indexed' % \
                        (full_path_filenames[index])
    
                if simulation_file:                
                    # Now, check the simulation runtime and confirm with user that it is 
                    # correct.  For the next simulation files, the runtime will be compared
                    # to this one to decide if the file is ok or not. 
                    time = sim.get_value('Time')
                    
                    print 'The first found simulation, %s, runs from %d s till %d s' % \
                        (sim.filename, time[0],time[-1])
                    timeOK = raw_input('Is this correct? y/n : ')
                    print '\n'
                    if timeOK == 'y' or timeOK == 'Y':
                        self.simulationstart = time[0]
                        self.simulationstop = time[-1]
                        first_file_indexed = True
                    else:
                        print '%s is NOT indexed' % (sim.filename)
                

            # The first simulation file is indexed and the attributes are 
            # initialised.  
            self.index_one_sim(sim, process=process)
            print '%s indexed' % (sim.filename)
            ########################################################################
            # The next step is to index all remaining files
            
            index += 1
            while index < len(full_path_filenames):
                # We try to index the remaining .mat files one by one 
                try:
                    sim = Simulation(full_path_filenames[index])
                except :
                    pass
                else:
                    # Now, check the simulation runtime against previously confirmed
                    # start and stop times
                    time = sim.get_value('Time')
                    
                    if self.simulationstart == time[0] and \
                        self.simulationstop == time[-1]:
                        # index this new simulation 
                        self.index_one_sim(sim, process=process)
                        print '%s indexed' % (sim.filename)
                                            
                    else:
                        print '%s, runs from %d s till %d s, therefore, it is NOT \
                             indexed' % (sim.filename, time[0],time[-1])
                
                index += 1
        
        else:
            # there are already files in the simdex
            index = 0
            while index < len(full_path_filenames):
                # We try to index the remaining .mat files one by one 
                try:
                    sim = Simulation(full_path_filenames[index])
                except :
                    pass
                else:
                    # Now, check the simulation runtime against previously confirmed
                    # start and stop times
                    time = sim.get_value('Time')
                    
                    if self.simulationstart == time[0] and \
                        self.simulationstop == time[-1]:
                        # index this new simulation 
                        self.index_one_sim(sim, process=process)
                        print '%s indexed' % (sim.filename)
                            
                    else:
                        print '%s, runs from %d s till %d s, therefore, it is NOT \
                             indexed' % (sim.filename, time[0],time[-1])
                
                index += 1            
        
        self.h5.close()
                


    def get_filenames(self, form='filename'):
        """
        Return a list of the filenames
        
        form = 'filename' (default): only the filenames
        form = 'path' : full path name
        """
        
        if form == 'path':
            result = self.files.values()
        elif form == 'filename':
            result = [os.path.split(x)[1] for x in self.files.values()]
        else:
            print 'form is not recognised'
            raise ValueError
            
        return result
    
    
    
    def exist(self, regex, tp = 'all'): 
        '''
        exist(regex, tp='all') 
        
        regex = regular expression
        tp = 'all' (default), 'par' or 'var'
        
        This function checks if a variable name exists in the index.
        In all cases, it returns a list.
        If tp = 'all' this list contains 2 lists of strings: 
            the first with all parameters that satisfy the regex, 
            the second with variables that satisfy regex
        If tp = 'par' or 'var' the return list only contains 
        the corresponding list.
        
        Attention: if you want to check if eg.  c[3].T exists, you have to 
        escape the [ and ] with a backlslash, like this:
        self.exist('c\[3\].T). Otherwise c3.T is sought for. This is 
        because in regex syntax, [] is used to indicate a set of characters.
        '''
        
        
        p = re.compile(regex, re.IGNORECASE)
        if tp == 'all' or tp == 'par':
            # we search for parameters in the fullnames
            matchespar = []
            for par in self.parameters:
                m = p.search(par)
                if m:
                    matchespar.append(par)
            # we also search in the shortnames, if present
            if self.__dict__.has_key('pardic'):            
                for par in self.pardic:
                    m = p.search(par)
                    if m:
                        matchespar.append(par)
            
            
        if tp == 'all' or tp == 'var':
            # we search for variables in the fullnames
            matchesvar = []
            for var in self.variables:
                m = p.search(var)
                if m:
                    matchesvar.append(var)
                    
            # we also search in the shortnames
            if self.__dict__.has_key('vardic'):
                for var in self.vardic:
                    m = p.search(var)
                    if m:
                        matchesvar.append(var)                    
          
        if tp == 'all':
            result = [matchespar, matchesvar]
        elif tp == 'par':
            result = matchespar
        elif tp == 'var':
            result = matchesvar
        else:
            print 'wrong input for tp'
            raise ValueError

        return result
    
    
    def __get_files(self, directory, non_wildcard_pattern):
        '''
        This function returns a list of filenames as strings, satisfying the 
        nonWildCardPattern
        '''
        
        # This function was found here on 26/11/2010:
        # http://codecomments.wordpress.com/2008/07/10/find-files-in-directory-using-python/
    
        fileList = os.listdir(directory)
        return [f for f in fileList if f.find(non_wildcard_pattern) > -1]



        
    def index_one_sim(self, simulation, process=None):
        '''
        Add a Simulation instanct to a Simdex instance
        
        This method indexes a single simulation into the simdex.  All simdex
        attributes are updated, and the h5 file is completed with the variables
        defined in process.variables AND with the results of the postprocessing
        as defined in process.pp
        
        simulation has to be a Simulation object
        process is a simman.Process object
        
        Convention: in the h5 file, the short names are used, but with any '.'
        replaced by '_dot_'.  The h5 file only contains variables, no parameters.
        
        '''
        
        # internal function to enhance readibility
        def index_one_var(variables, varmap, var, index):
            """
            Updates the variables and varmap with var, keeping everything sorted
            Important: index is the position of the last found var in variables
            
            Returns the new variables, varmap and index
            """
            
            
            if var==variables[index]:
                # var is the first element in variables, update varmap
                varmap[index,-1] = 1
                pos = index+1
            else:
                try:
                    # search for it in variables, but only in the part AFTER index
                    pos=variables[index:].index(var)+index
                    varmap[pos,-1] = 1
                except(ValueError):
                    # this variable was not found.  Add it in the right position
                    # keeping the list in sorted order
                    pos = bisect.bisect_left(variables, var, lo=index)
                    variables.insert(pos,var)
                    # make new row in variablemap and add '1' in the last column
                    varmap = np.insert(varmap, pos, 0, axis=0)
                    varmap[pos,-1] = 1
                    pos+=1
            return variables, varmap, pos
                    
        # internal function to enhance readibility
        def index_one_par(parameters, parmap, parvalues, par, index, parvalue):
            """
            Updates the parameters, parvalues and parmap with par, 
            keeping everything sorted.
            Important: 
                - index is the position of the last found par in parameters
                - parvalue is the value of par 
            
            Returns the new parameters, parmap, parvalues and index
            """
          
            if par==parameters[index]:
                # par is the first element in parameters, update parmap, parvalues
                parmap[index,-1] = 1
                parvalues[index, -1] = parvalue
                pos = index+1
            else:
                try:
                    # search for it in parameters, but only in the part AFTER index
                    pos=parameters[index:].index(par)+index
                    parmap[pos,-1] = 1
                    parvalues[pos, -1] = parvalue
                except(ValueError):
                    # this parameter was not found.  Add it in the right position
                    # keeping the list in sorted order
                    pos = bisect.bisect_left(parameters, par, lo=index)
                    parameters.insert(pos,par)
                    # make new row in parametermap and add '1' in the last column
                    parmap = np.insert(parmap, pos, 0, axis=0)
                    parmap[pos,-1] = 1
                    parvalues = np.insert(parvalues, pos, 0, axis=0)
                    parvalues[pos,-1] = parvalue
                    pos+=1
            return parameters, parmap, parvalues, pos
        
        
        def add_meta(simulation, key):
            """Create a node for the simulation and add data to /Metadata"""
            
            def analyse_log(log_file):
                """
                analyse_log(log_file)
                log_file = string with path to a dslog.txt file
                
                Check if the simulation ended successfully, which solver was used and
                how much time it took.  Optionally, show the number of this and that
                Returns a dictionary with the results
                
                """
                
                summary = {'successful':False}
                lf = open(log_file, 'r')
                lines = lf.readlines()    
                for line_number, line in enumerate(lines):
                    if line.find('Integration terminated successfully at T =') > -1:
                        summary['successful'] = True
                    elif line.find('CPU time for integration') > -1 or \
                         line.find('CPU-time for integration') > -1:
                        summary['CPU_time'] = line.split(' ')[-2]
                    elif line.find('Number of (successful) steps') > -1:
                        summary['steps_ok'] = line.split(' ')[-1]
                    elif line.find('Number of rejected steps') > -1:
                        summary['steps_nok'] = line.split(' ')[-1]
                    elif line.find('Integration started at 0 using integration method:') > -1:
                        summary['algorithm'] = lines[line_number + 1].strip('\n')
                    elif line.find('Integration started at T = 0 using integration method') > -1:
                        summary['algorithm'] = line.split(' ')[-1].strip('\n')
                    elif line.find('This simulation timed out and was killed') > -1:
                        summary['successful'] = False
                        summary['timed_out'] = True
                    elif line.find('Corresponding result file') > -1:
                        summary['result file'] = line.split(' ')[-1].strip('\n')
                lf.close()
                if summary.has_key('steps_nok'):    
                    summary['perc_wrong'] = 100. * float(summary['steps_nok']) / \
                                            float(summary['steps_ok'])
                else:
                    summary['perc_wrong'] = 0
                return summary            
            
            class Meta(tbl.IsDescription):
                SID = tbl.StringCol(itemsize=16)
                path = tbl.StringCol(itemsize=160)
                log_analysed = tbl.BoolCol()
                successful = tbl.BoolCol()
                algorithm = tbl.StringCol(itemsize=16)
                CPU_time = tbl.Float32Col()
                steps_ok = tbl.Int32Col()
                steps_nok = tbl.Int32Col()
                timed_out = tbl.BoolCol()
                perc_wrong = tbl.Float32Col()
                
            self.openh5()
            
            # if it's the first simulation, we need to create the Metadata tbl
            try:
                meta = self.h5.getNode(self.h5.root.Metadata)
            except(tbl.NoSuchNodeError):
                meta = self.h5.createTable('/', 'Metadata', Meta, 
                            title='All metadata for the simulations')
            
            # check if there's a log file 
            logfilename = simulation.filename.replace('result_','dslog_')\
                                             .replace('.mat','.txt')
            try:
                log = analyse_log(logfilename)
                loganalysis=True
            except(IOError):
                print 'No %s found, log-analysis not possible' % logfilename
                loganalysis=False

            # create all values for a new row            
            row = meta.row
            row['SID'] = key
            row['path'] = simulation.filename
            row['log_analysed'] = loganalysis
               
            if loganalysis:
                for k in log:
                    row[k] = log[k]
                
            row.append()
            meta.flush
            
            # Create the node for all variable arrays
            var_grp = self.h5.createGroup('/', key, title='All variables, as arrays')
            
            self.h5.flush()
        
        
        def update_h5(simulation, key):
            """
            Update the h5 file with the variables defined by the process.
            Return a dictionary with shortname/longname pairs of everything
            that has been added to the h5.
            

            Still to add: extraction of metadata from the log
            """
                        
            var_grp = self.h5.getNode('/', key)
           
            if process is None:
                # add all variables to the h5, with full names
                vardic = dict(zip(simulation.variables, simulation.variables))
                extracted = simulation.extract(var=vardic, arrays = 'each')           
                for shortname, arr in extracted.iteritems():
                    name = shortname.replace('.', '_dot_')
                    self.h5.createArray(var_grp, name, arr)
                
            else:
                extracted = simulation.postprocess(process)
                vardic = {}
                for shortname, arr in extracted.iteritems():
                    name = shortname.replace('.', '_dot_')
                    ispar = process.parameters.has_key(shortname) or \
                            process.parameters.has_key(name)
                                
                    if not ispar:
                        self.h5.createArray(var_grp, name, arr)
                        try:
                            longname = process.variables[shortname]
                        except(KeyError):
                            longname = shortname
                        vardic[shortname] = longname
                
            self.h5.flush()
            return vardic
        
        # separate parameters from variables for simulation 
        simulation.separate()
        
        if self.simulations == []:
            # this is the first simulation to be added to self
           key = self._gen_key()            
           self.simulations.append(key)
           self.files[key] = simulation.filename
           add_meta(simulation, key)
           vardic = update_h5(simulation, key)
               
           if self.verbose:
               print "key = %s, filename = %s" % (key, self.files[key])
           self.parameters = simulation.parameters # a LIST
           self.variables = simulation.variables  # a LIST           
           self.parametermap = np.ndarray((len(self.parameters), 1))
           self.parametermap[:, 0] = 1
           self.parametervalues = copy.copy(self.parametermap)
           self.parametervalues[:, 0] = np.array(simulation.parametervalues)
           self.variablemap = np.ndarray((len(self.variables), 1))
           self.variablemap[:, 0] = 1
           self.vardic = vardic
           
           self.h5.close()
        
        else:
            # new simulation to be added to existing ones            
            # First, add the simulation key to self.simulations            
            key = self._gen_key()            
            self.simulations.append(key)
            self.files[key] = simulation.filename
            add_meta(simulation, key)
            vardic = update_h5(simulation, key)
                      
            if self.verbose:
                print "Added simulation to set with at least one other simulation"
                print "key = %s, filename = %s" % (key, self.files[key])
            
            # Second, make new columns for parametermap, parametervalues and 
            # variablemap
            self.parametermap = np.append(self.parametermap,
                                          np.zeros((len(self.parameters), 1)),
                                          axis=1)
            self.parametervalues = np.append(self.parametervalues,
                                          np.zeros((len(self.parameters), 1)),
                                          axis=1)
            self.variablemap = np.append(self.variablemap,
                                          np.zeros((len(self.variables), 1)),
                                          axis=1)                                          
            
            position = 0            
            for var in simulation.variables:
                self.variables, self.variablemap, position = index_one_var(self.variables, self.variablemap, var, position)
            
            position = 0            
            for par, parvalue in zip(simulation.parameters, simulation.parametervalues):
                self.parameters, self.parametermap, self.parametervalues, position = index_one_par(self.parameters, self.parametermap, self.parametervalues, par, position, parvalue)
                
                  
            # finally, create or update self.vardic and self.pardic
            if process is not None:
                if not self.__dict__.has_key('vardic'):
                    # it's the first time we do a postprocessing on this simdex,
                    # probably because this was the first simulation to be indexed
                    self.vardic = vardic
                else:
                    self.vardic.update(vardic)
                               
                if process.parameters is not None:
                    try:
                        self.pardic.update(process.parameters)
                    except(AttributeError):
                        self.pardic=process.parameters

            # this method can be called on itself: close the h5 file afterwards
            self.h5.close()
            
    def filter_similar(self, SID):
        '''
        Return a new simdex with similar simulations as SID (SIDxxxx)        
        
        Create a new Simdex object from self with only those simulations 
        that have identical parameter and variable lists as SID.  This means
        that we suppose the model is identical, but some parameters may have 
        a different value
        '''
        
        # Approach: copy self and remove the unneeded columns from 
        # parametermap, parametervalues and variablemap by slicing
        
        # Make sure the h5 file is closed (for the deepcopy to work)
        self.h5.close()
        
        try:
            seqnb = self.simulations.index(SID)
        except(ValueError):
            print "This SID is not present in the simdex: %s" % SID
            raise
        
        newsimdex = copy.deepcopy(self)
        newsimdex.simulations = []
        
        parmap = self.parametermap[:, seqnb]
        varmap = self.variablemap[:, seqnb]
        
        sims_to_keep = []
        
        for i in range(len(self.simulations)):
            if np.all(self.parametermap[:, i] == parmap) and \
                np.all(self.variablemap[:, i] == varmap):
                # we have catched an identical simulation
                sims_to_keep.append(True)
                newsimdex.simulations.append(self.simulations[i])
            else:
                sims_to_keep.append(False)
            
        # slicing only works with an array
        s = np.array(sims_to_keep)
        newsimdex.parametermap = newsimdex.parametermap[ : , s]
        newsimdex.parametervalues = newsimdex.parametervalues[ : , s]
        newsimdex.variablemap = newsimdex.variablemap[ : , s]
        
        # remove all empty rows and corresponding parameters/variables
        newsimdex.cleanup()
        
        return newsimdex

    def filter_selection(self, selection):
        """
        Return a new simdex containing only the SID's in selection.
        
        selection is a list with 'SIDxxxx' strings.
        It DOES NOT have to be in the right order.
        """
        
        # Make sure the h5 file is closed (for the deepcopy to work)
        self.h5.close()
        
        newsimdex = copy.deepcopy(self)
        cols_to_remove = []
        
        for col, sid in enumerate(self.simulations):
            try:
                selection.index(sid)
            except(ValueError):
                # sid not in selection: remove it
                cols_to_remove.append(col)
                newsimdex.simulations.remove(sid)
                
        newsimdex.parametermap = np.delete(newsimdex.parametermap, 
                                           cols_to_remove, 1)
        newsimdex.parametervalues = np.delete(newsimdex.parametervalues, 
                                              cols_to_remove, 1)
        newsimdex.variablemap = np.delete(newsimdex.variablemap, 
                                          cols_to_remove, 1)
        
        newsimdex.cleanup()
        return newsimdex

    def filter_remove(self, selection):
        """
        Return a new simdex without the SID's in selection.
        
        selection is a list with 'SIDxxxx' strings.
        It DOES NOT have to be in the right order.
        """
        
        # Make sure the h5 file is closed (for the deepcopy to work)
        self.h5.close()
        
        newsimdex = copy.deepcopy(self)
        cols_to_remove = []
        
        for col, sid in enumerate(self.simulations):
            try:
                selection.index(sid)
            except(ValueError):
                # this sim is to be kept           
                pass
            else:
                # this simulation is found in selection ==> to be removed
                cols_to_remove.append(col)
                newsimdex.simulations.remove(sid)
                
        newsimdex.parametermap = np.delete(newsimdex.parametermap, 
                                           cols_to_remove, 1)
        newsimdex.parametervalues = np.delete(newsimdex.parametervalues, 
                                              cols_to_remove, 1)
        newsimdex.variablemap = np.delete(newsimdex.variablemap, 
                                          cols_to_remove, 1)
        
        newsimdex.cleanup()
        return newsimdex    
    
    
    def filter(self, pardic):
        '''
        Return a new simdex, filtered with the criteria as in pardic
        
        pardic is a dictionary of parameter:value pairs
        If a value is omitted (empty string), all simulations that have any 
        value for this parameter are fine
        
        Get all simulations that satisfy pardic (AND relation) and 
        return them as a new Simdex object
        
        Attention: a tolerance is defined internally in this method to enable
        filtering with floats.  The tolerance is currently set to 0.5% 
        '''
        
        # Approach: first find the parameters from pardic in self.parameters
        # and remove all rows from parametermap and parametervalues that aren't 
        # playing the game.
        # Then separate the parameters with values from the ones without
        
        # I select the rows by creating another array with the row numbers
        # and slice self.parametermap and self.parametervalues with that array
        
        tolerance = 0.005        
        # list of rownumbers from self.parameters with concerned parameters
        rows = []
        values = []    
        for i in pardic:
            rows.append(self.parameters.index(i))
            values.append(pardic[i])
        
        values = np.array(values)
        arows = np.array(rows)
        reduced_par_map = self.parametermap[arows]
        reduced_par_val = self.parametervalues[arows]
        
        
            
        # next step: remove all simulations that do NOT have the parameters
        # with empty strings in pardic
        
        # get row numbers of rows in reduced_par_map where the value doesn't 
        # matter
        parmaprows = np.array([x for (x, y) in zip(range(len(pardic)), \
            pardic.values()) if y==''])
        
        # if there are no parmaprows, we don't need to filter on empty strings
        if len(parmaprows)>0:
            selmap = reduced_par_map[parmaprows]
            # selmap contains rows with 0 and 1's for each of the simulations
            # (columns).  We need to get the simulation numbers (column numbers)
            # that are FINE, meaning that the columns are unit columns
            satisfyingmap = selmap.all(axis = 0)
            # satisfying is a boolean array, true if corresponding simulation 
            # is still in the run for selection
        else:
            # satisfyingmap has to be known.  
            # In this case a boolean array with only True values
            satisfyingmap = np.array(range(len(self.simulations)))>-1
        
        # now we need to get only the rows for which the values matter
        # and compare those values for each simulation with 'values'
        parvalrows = np.array([x for (x, y) in zip(range(len(pardic)), \
            pardic.values()) if y != ''])
        if len(parvalrows) > 0:
            selval = reduced_par_val[parvalrows]
            values = values[parvalrows]
            # we do not compare the values directly, but allow deviations 
            # smaller than tolerance.  
            abs_diff_values = np.abs(selval - values)
            satisfyingval = np.all(abs_diff_values < (tolerance * values), 
                                   axis = 0)
            # again a boolean array
        else:
            # satisfyingval has to be known.  
            # In this case a boolean array with only True values
            satisfyingval = np.array(range(len(self.simulations))) > -1
            
        
        # only simulations satisfying both the requirements are selected
        # first (dummy) row of self.simulations has also to be kept
        satisfying = satisfyingmap & satisfyingval
                
        # we create a new simdex object, with identical properties as self
        # but containing only the simulations we have selected
        
        newsimdex = copy.deepcopy(self)
        newsimdex.simulations = \
            [x for (x, y) in zip(self.simulations, satisfying) if y == True]
        newsimdex.parametermap = self.parametermap[:, satisfying]
        newsimdex.parametervalues = self.parametervalues[:, satisfying]
        newsimdex.variablemap = self.variablemap[:, satisfying]
            
        # we want to keep track of the parameters we have filtered on
        # this should be improved: if two identical keys occur, take the key
        # with associated value (instead of '')
        newsimdex.filterset.update(pardic)
        
        # Removing unused parameters and variables from the filtered simdex
        newsimdex.cleanup()
        if newsimdex.get_filenames() == []:
            raise ValueError("No single simulation could satisfy this filter")
        
        print newsimdex


        return newsimdex
    
    def cleanup(self):
        '''
        Removes unused parameters, variables and filenamesfrom a simdex
               
        '''
        # First, remove all columns from parametermap, parametervalues and 
        # variablemap that are not corresponding to self.simulations anymore
        
        
        
        new_files = {}
        for col, sid in enumerate(self.simulations):
            new_files[sid] = self.files[sid]
        self.files = new_files
        

        # next, remove all parameters/variables that are not in the maps anymore
        pars_to_keep = np.any(self.parametermap, 1)
        self.parametermap = self.parametermap[pars_to_keep]
        self.parametervalues = self.parametervalues[pars_to_keep]
        self.parameters = [x for (x, y) in \
            zip(self.parameters, pars_to_keep) if y == True]
        vars_to_keep = np.any(self.variablemap, 1)
        self.variables = [x for (x, y) in \
            zip(self.variables, vars_to_keep) if y == True]
        self.variablemap = self.variablemap[vars_to_keep]
        

    def get(self, name, aggregate=None):
        """
        Return a Result instance with SID:value pairs for par or var name
        
        If the name is a sub-variable, the corresponding variable for all
        mothers will be extracted and put in a single array according to aggregate.  
        
        aggregate = None, 'sum' or 'mean' : if None, the values in the Result
        object will contain the trajectories for all variables.  
        If aggregate is 'sum', all trajectories are summed, if it is 'mean', 
        the mean value of all trajectories is computed.
        
        If name is a parameter and a simulation does NOT have the parameter, 
        the value in the result object is None.
        
        """
        
        # There are many different options for name
        found_name = False        
        # 1. name is a short parameter name 
        # ==> attribute the longname to name
        try:
            if self.pardic.has_key(name):
                resdic = self._get_par(self.pardic[name])
                time = None
                found_name = True
        except(AttributeError):
            pass
        
        # 2. it is a short variable name
        # keep the short name cause that is the array name in the h5 file
        if not found_name:
            try:
                if self.vardic.has_key(name):
                    resdic = self._get_var_h5(name, selection=self.simulations)
                    time = self._get_var_h5('Time', selection=self.simulations)
                    found_name = True
            except(AttributeError):
                pass

        # 3. it is a long parameter name
        # keep it            
        if not found_name:
            try:
                parindex = self.parameters.index(name)
                resdic = self._get_par(name)
                time = None
                found_name = True
            except:
                pass
            
        # 4. Last regular option, it is a long variable name
        # ==> two options: if it is in a vardic, use the short name, 
        # else use it as it comes
        if not found_name:
            try:
                varindex = self.variables.index(name)
                found_name = True
            except:
                pass
            else:
                #it is a long variable name
                try:
                    for shortname, longname in self.vardic.iteritems():
                        if name == longname:
                            print 'shortname found', shortname
                            resdic = self._get_var_h5(shortname, 
                                                    selection=self.simulations)
                            time = self._get_var_h5('Time', 
                                                    selection=self.simulations)
                except(AttributeError):
                    pass
                else:
                    # it is a long variable name that is not in the h5
                    raise NotImplementedError('This variable name was not yet in the h5 file. \
                    \nAdapt the process to get it in there')
                    
                
        # 5. aggregation option: the name is a sub_var
        if not found_name and self.process.sub_vars.has_key(name):
            # we loop over the mothers and put all the arrays together
            for m in self.process.mothers:
                single_array = self._get_var_h5(var=m+'_'+name, 
                                                selection=self.simulations)
                if m == self.process.mothers[0]:
                    #initiate the resulting dictionary
                    resdic = copy.deepcopy(single_array)
                else:
                    for k in resdic.keys():
                        resdic[k] = np.column_stack((resdic[k], single_array[k]))
            
            if aggregate == 'sum':
                resdic = {k:np.sum(v, axis=1) for k,v in resdic.items()}
            elif aggregate == 'mean':
                resdic = {k:np.mean(v, axis=1) for k,v in resdic.items()}
            
            # reshape the array if the second dimension is larger than the first
            shape = resdic.values()[0].shape      
            try:
                if shape[0]==1 and shape[1] > 1:
                    resdic = {k:v.reshape((shape[1])) for k,v in resdic.items()}
            except:
                # the shape probably is of length 1 or even 0
                pass
            
            time = self._get_var_h5('Time', selection=self.simulations)
            found_name = True
  
        if not found_name:
            print "%s was not found in this simdex" % name
            print 'maybe you want to use any of these parameters/variables?'
            return self.exist(name)
        else:
            return Result(resdic, time=time, 
                          identifiers = self.identifiers, year=self.year)
        

        
    def _get_var_h5(self, var, selection=[]):
        """Get values of variables that are stored in the h5 file"""
        
        self.openh5()
        
        values = {}
        var_replaced = var.replace('.', '_dot_')
        if selection == []:
            selection = [n._v_name for n in self.h5.listNodes('/')]
            
        for node in self.h5.iterNodes('/'):
            try:
                # move on if this node is NOT in the selection
                selection.index(node._v_name)
                try:
                    # look up the variable in this node
                    array = self.h5.getNode(node, name=var_replaced)
                    values[node._v_name] = array.read()
                except(tbl.NoSuchNodeError):
                    # either the node is Metadata, or this variable does not
                    # exist in this node (perfectly possible and normal)
                    pass                    
                    #raise tbl.NoSuchNodeError(var + " not found in node " + node._v_pathname)
            except(ValueError):
                # it's a node that was not in the selection
                if self.verbose:
                    print " node not selected: ", node._v_name
                pass
            
            
       
        self.h5.close()
        return values        
    
    
    
    def _get_par(self, parameter):
        '''
        Return a dictionary with SID:parametervalue pairs
        
        This is a private method.  You should use get()
        parameter = string with exact (long) parameter name. 
        
        If a simulation does NOT have the parameter, the value in 
        the dictionary is None
        '''
        
        parindex = self.parameters.index(parameter)
            # row number of the parameter to be returned
        
#        result = [range(1, len(self.simulations)),\
#            self.parametervalues[parindex, 1:], self.simulations[1:]]
        
        presence = self.parametermap[parindex,:]        
        value = self.parametervalues[parindex, :]
        # take care, first element is dummy value (zero)
        
        result = {}
        for i, sid in enumerate(self.simulations):
            if presence[i] == 0:
                result[sid] = None
            elif presence[i] == 1:
                result[sid] = value[i]
            else:
                raise NotImplementedError('It is not possible to have something\
                  else than 0 or 1 in parametermap')
        
        return result

    def plot(self, variable):
        '''
        plot(variable) - variable = string with variable name (short or long)
        
        Creates a matplotlib figure with a simple plot of the timeseries for 
        each of the simulations in self
        '''
        
        result = self.get(variable)
        [fig, lines, leg] = result.plot(variable)

        return [fig, lines, leg]
        

    def scatterplot(self, X, Y):
        '''
        Creates a matplotlib figure with a simple plot of Y versus X for 
        each of the simulations in self 
        '''
        
           
        # 1. and 2.
        toplot_X = self.get(X).val
        toplot_Y = self.get(Y).val
        
        
        # 3. and 4.
        plotstring = ''
        plotlegend = ''
        
        for sid in toplot_X:
            if toplot_Y.has_key(sid):
                plotstring += ''.join(['toplot_X["', sid, '"], toplot_Y["', sid, '"], "D", '])
                try:
                    label = self.identifiers[sid]
                except KeyError:
                    label=sid
                plotlegend += ''.join(['"', label + '", '])        
        
        # remove last semicolon
        plotstring = plotstring[:-1]
        plotlegend = plotlegend[:-1]
        
        fig = plt.figure()
        ax = fig.add_subplot(111)
        lines = eval("ax.plot(" + plotstring + ")")
        leg = eval("ax.legend((" + plotlegend + "))")
        
        ax.set_xlabel(X)
        ax.set_ylabel(Y)
        
        return [fig, lines, leg]

    
    def get_SID(self, regex):
        '''
        Get a list with SID's for a given search expression (regex)
        
        regex = regular expression, not case sensitive
        
        Return a list of simulations (SID) of which the filenames match the regex
        '''
        p = re.compile(regex, re.IGNORECASE)
        matches = []
        sids = []
        # important: iterate always with self.simulations to keep the right order!!        
        for k in self.simulations:
            m = p.search(self.files[k])
            if m:
                matches.append(self.files[k])
                sids.append(k)
        
        print 'SID     ', 'Filename\n'
        for i, sim in zip(sids, matches):
            print i, '   ', sim
        return sids
        
    
    def save(self, filename):
        """
        save(filename)
        
        Save the Simdex object by pickling it with cPickle
        
        
        To unpickle (= load) use the following command:
            objectname = pickle.load(open(filename,'rb'))
            # 'rb' stands for 'read, binary'
            
        """
        
        # the h5 file raises errors, so let's remove it.  Anyway, we keep the 
        # reference to it via the h5_path string
        
        del self.h5
        print 'self.h5 removed'

        f = file(filename,'wb')
        # wb stands for 'write, binary'
        pickle.dump(self, f)
        f.close()
        
        return filename + ' created'
        
    def postproc(self):
        """Run the post-processing"""
        pass
    
    def apply(self, function_call):
        """
        Apply the function_call to each variable in each simulation.
        E.g, if the simdex contains a variable called QHeat as a timeseries,
        you can use this method like this to compute the total integrated QHeat
        for each of the simulations:
            
            simdex.apply(np.trapz(QHeat, time))
            
        Returns a dictionary with SID/result pairs
        
        """
        result={}
        for SID in self.simulations:
            result[SID] = eval(function_call)
                
        return result
        
    def apply2(self, function, variable):
        result={}
        for k,v in self.get(variable).items():
            result[k] = function(v)
        return result
        
    def apply3(self, function, variable, *args, **kwargs):
        result={}
        for k,v in self.get(variable).items():
            result[k] = function(v, *args, **kwargs)
        return result
        
    def apply4(self, function, **kwargs):
        
        arg_dict = {fun_arg: self.get(sim_args) for fun_arg, sim_args in kwargs.items()}
        result = {}
        for SID in arg_dict[kwargs.keys()[0]]:
            fun_kwargs = {fun_arg: sim_dict[SID] for fun_arg, sim_dict in arg_dict.items()} 
            result[SID] = function(**fun_kwargs)
        return result
 

        
def apply(function, results):
    """
    Apply the function on each of the values in results.
    Results is a dictionary with SID/value pairs, typically as a result 
    from a simdex.get() call. 
    
    Returns a SID/function(value) dictionary    
    """
        
    result = {}
    for k,v in results.items():
        result[k] = function(v)
    return result


class Result(object):
    """
    Class containing the result for one single variable but for different 
    simualations.  An instance from this class is returned from Simdex.get()
    
    This class also contains the plot functionality and methods to apply 
    basic operations and functions to it. 
    """
    
    def __init__(self, values, time=None, identifiers=None, **kwargs):
        """
        Instantiate a Result object. 
        
        Variables
        ---------
        
        values = dictionary {sid:values}
        time (optional) = dictionary {sid:time}
        identifiers (optional) = dictionary {sid:identifier}
        **kwargs are converted into attributes.  This is useful to pass eg. the 
        year for the data (use for example year=2010)
        
        """
        
        self.val = values
        if time is not None:
            self.time = time
            self.time4plots = {}
        if identifiers is not None:
            self.identifiers = identifiers
        self.simulations = sorted(self.val.keys())
        
        for k,v in kwargs.items():
            setattr(self, k, v)
            
    def values(self):
        """
        Return a list with as elements, the values of the variable in the order 
        of the sid's
        
        It does not seem a good idea to return an array by default, cause the 
        variables for different SID's can have different lengths. 
        Exception: when the length of each of the variables is 1, a reshaped 
        array is returned.
        
        If a value in a single length array is None, it is replaced by NaN in the
        returned array.
        """
        
        result = [self.val[sid] for sid in self.simulations]
        
        lengths=[]
        for i,x in enumerate(result):
            try:
                l = len(x)
            except TypeError:
                # x is a value, it is a numpy.float64, so length=1
                if x is None:
                    result[i]=np.NaN
                l = 1
            lengths.append(l)
                    
        ls = np.array(lengths)
        
        if np.all(ls==1):
            return np.array(result).reshape(len(ls))
        else:
            return result
        
    def trapz(self):
        """
        Integrate the values(time) using the composite trapezoidal rule
        Returns an array with the integrated values, in sorted order
        """
        
        if not hasattr(self, 'time'):
            raise AttributeError("This Result object has no attribute 'time'")
        
        result = []
        for sid in self.simulations:
            result.append(np.trapz(self.val[sid], x=self.time[sid]))
        
        return np.array(result)
        

    def aggregate(self, period=86400, interval=3600):
        
        def aggregate_by_time(var, time, period=86400, interval=900):
            """
            Function to calculate the aggregated average of a timeseries by 
            period (typical a day) in bins of interval seconds (default = 900s).
            
            Returns an array with period/interval values, one for each interval
            of the period. 
            
            A few limitations of the method:
                - the period has to be a multiple of the interval
                - the time vector needs to have AT LEAST an entry at each interval 
                  boundary
            
            This function can be used in the post-processing.
            This function was proposed on www.stackoverflow.com on a question of
            RDC about aggregation of data.
            """
            assert (period % interval) == 0
            ipp = period / interval
        
            midpoint = np.r_[time[0], (time[1:] + time[:-1])/2., time[-1]]
            cumsig = np.r_[0, (np.diff(midpoint) * var).cumsum()]
            grid = np.linspace(0, time[-1], np.floor(time[-1]/period)*ipp + 1)
            cumsig = np.interp(grid, midpoint, cumsig)
            
            return np.diff(cumsig).reshape(-1, ipp).sum(0) / period       

        result = {}        
        for sid in self.simulations:
            result[sid] = aggregate_by_time(self.val[sid], self.time[sid], interval=interval)
            
        return result

    def plot(self, ylabel=None):
        """
        Creates a matplotlib figure with a simple plot of the timeseries for 
        each of the simulations in self.val
        
        A string can be passed (ylabel) that will be used to label the y-axis
        """
        
        # In order to plot the timeseries nicely with dates, we use plot_date()
        def create_time4plot(sid):
            """Convert time into matplotlib format"""
            start = datetime(self.year, 1, 1)
            datetimes = [start + timedelta(t/86400.) for t in self.time[sid]]
            self.time4plots[sid] = date2num(datetimes)
            
        # check existence of attributes
        if not hasattr(self, 'year'):
            print 'We suppose the data is for 2011'
            self.year=2011
       
        fig = plt.figure()
        ax = fig.add_subplot(111)
        ax.hold = True        

        # we have to make a distinction between plotting timeseries and other results
        try:
            if len(self.time[self.simulations[0]])==len(self.val[self.simulations[0]]): 
                plot_type='plot_date'
            elif len(self.val[self.simulations[0]]) <> 1:
                # most probably an aggregated array. So plot the x values for 
                # each SID as a series 
                plot_type='aggregated'
            else:
                # length == 1, so single_value
                plot_type = 'single_value'
        except:
            try:
                if len(self.val[self.simulations[0]]) <> 1:          
                    # most probably an aggregated array. So plot the x values for 
                    # each SID as a series 
                    plot_type='aggregated'
                else:
                    # length == 1, so single_value
                    plot_type = 'single_value'
            except:
                # I get an exception when trying to get the length of a single
                # intgegrated value
                plot_type = 'single_value'
                
        if plot_type=='plot_date':
            for sid in self.simulations:
                try:
                    label = self.identifiers[sid]
                except KeyError:
                    label=sid
                if not self.time4plots.has_key(sid):
                    create_time4plot(sid)
                    
                ax.plot_date(self.time4plots[sid], self.val[sid], fmt='', ls = '-', 
                             label=label)            
        elif plot_type == 'single_value':
            ax.plot(range(len(self.simulations)), self.values(), 'D')
            ax.set_xticks(range(len(self.simulations)))
            ticklabels = [self.identifiers[sid] for sid in self.simulations]
            ax.set_xticklabels(ticklabels)
        else:
            # aggregated, plot lines with markers            
            for sid in self.simulations:
                try:
                    label = self.identifiers[sid]
                except KeyError:
                    label=sid
                
                ax.plot(self.val[sid], 'o-', label=label)            
                             
        leg = ax.legend()
        lines = ax.get_lines()
        if plot_type == 'plot_date':
            ax.set_xlabel('time')
        ax.set_ylabel(ylabel)
        plt.grid()
        
        return [fig, lines, leg]
            
        

class Process(object):
    """
    Class defining pre- and post processing of a simulation
    
    The variable 'Time' is automatically created
    
    This documentation needs completion, mainly the __init__() method
    
    
    """
    
    def __init__(self, mothers=None, parameters=None, sub_pars=None, variables=None,
                 sub_vars=None, pp=None, integrate=None):
        """Instantiate the Process object
        
        Note for pp: surround the names of variables by spaces so they can be
        looked up in the parameters and variables dictionaries.
        
        """
        
        pp_int = []
               
        # make/complete the variables and parameter dicts, full paths
        if variables is None:
            self.variables = {}
        else:
            self.variables = copy.copy(variables)
               
        if parameters is None:
            self.parameters = {} 
        else:
            self.parameters = copy.copy(parameters)
               
        if mothers is not None:
            self.mothers = copy.copy(mothers)
            for m in self.mothers:
                if sub_vars is not None:
                    self.sub_vars = copy.copy(sub_vars)                    
                    for shortname, longname in self.sub_vars.iteritems():
                        self.variables['_'.join([m, shortname])] = '.'.join([m, longname])
                else:
                    self.sub_vars = {}
                if sub_pars is not None:
                    self.sub_pars = copy.copy(sub_pars)
                    for shortname, longname in self.sub_pars.iteritems():
                        self.parameters['_'.join([m, shortname])] = '.'.join([m, longname])
                else:
                    self.sub_pars = {}
        else:
            self.mothers = []
        # paramaeters = contains short and long names of the parameters we need.
        # The data will be extracted from the .mat files and put in a dictionary
        # The short names will be the keys in that dictionary     
        if self.variables is not {}:
            if not self.variables.has_key('Time'):
                self.variables['Time'] = 'Time'
        
        if integrate is not None:
            for name, conversion in integrate.iteritems():
                # maka a pp string for this integration action
                s = ''.join([name+'_Int',
                              ' = ',
                              'np.trapz( ',
                              name,
                              ' , ',
                              'Time',
                              ' ,axis=0)*',
                              str(conversion),
                              ' if ',
                              name,
                              ' .shape[0]== Time .shape[0] else np.array([0.0])'
                              ])
                pp_int.append(s)

        # now put the pp_int in front of the self.pp if any        
        self.pp = []
        self.pp.extend(pp_int)
        if pp is not None:
            self.pp.extend(pp)
            
        
        
    def __str__(self):
        """Return a print string"""
        
        s = '\n'+79*'-'+'\n'
        s += 'The content of this Process object is:\n'
        s += 'Parameters:'
        for shortname,longname in sorted(self.parameters.iteritems()):
            s += '\t'.join(['\n', shortname ,'=', longname])
        
        s += '\n\nVariables:'
        for shortname,longname in sorted(self.variables.iteritems()):
            s += '\t'.join(['\n', shortname ,'=', longname])
        
        s += '\n\nPost-processing:\n'        
        if self.pp is not None:
            ppprint = '\n'.join(self.pp)
        else:
            ppprint = '\nNo post-processing defined\n'
        s += ppprint
        
        return s
        

                
    

    




def load_simdex(filename):
    """load and return a previously saved Simdex object"""
    
    result = pickle.load(open(filename,'rb'))
    result.h5 = tbl.openFile(result.h5_path, 'a')
    result.h5.close()
    return result
    